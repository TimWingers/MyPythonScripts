# Оптимизационный алгоритм Пути коммивояжера
import numpy as np
import math
# сгенерируем случайную карту, по которой будет перемещаться коммивояжер
random_seed = 1729  #фиксации изначального сета рэндома
np.random.seed(random_seed)
N = 40  # число пар координат для каждого города
x = np.random.rand(N)
y = np.random.rand(N)
points = zip(x,y) #соединяем значения x y для создание списка координат для каждого города
cities = list(points)
itinerary = list(range(0,N)) #обход всех городов в порядке их следования в списке cities
# Этот способ записи эквивалентен следующему:
# itinerary = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,
# 22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39]
# предположим, что перемещение на расстояние 1 обходится в 1 доллар
# независимо от направления и от того, через сколько городов проезжаем.
# Запишем функцию, которая получает в аргументах cities и itinerary и
# возвращает набор отрезков, соединяющих все города
# в списке в порядке, заданном в маршруте
def genlines(cities,itinerary):
  lines = [] #пустой список, в котором будет храниться информация об отрезках
  for j in range(0,len(itinerary) - 1):
    lines.append([cities[itinerary[j]],cities[itinerary[j + 1]]])
#перебираем все города и на каждом шаге добавляем в коллекцию lines новый
# отрезок, связывающий текущий город со следующим
  return(lines)
# print(lines[0]) - координаты первого отрезка
# Теперь зададим функцию для вычисления расстояния.
def howfar(lines):
  distance = 0 # Сначала общее расстояние определяется равным 0,
  for j in range(0,len(lines)):
    distance += math.sqrt(abs(lines[j][1][0] - lines[j][0][0])**2 + \
    abs(lines[j][1][1] - lines[j][0][1])**2)
# после чего для каждого элемента в списке lines к переменной distance
# прибавляется длина этого отрезка. Для вычисления длин отрезков
# используется теорема Пифагора.
  return(distance)
# Т.е. функция получает на входе список отрезков и выводит сумму их длин.
# определим общее расстояния, которое преодолеет наш коммивояжер:
totaldistance = howfar(genlines(cities,itinerary))
print(totaldistance)
# Чтобы получить представление о том, что означает этот результат, полезно 
# построить диаграмму маршрута. Для этого мы создадим функцию plotitinerary()
import matplotlib.collections as mc
import matplotlib.pylab as pl
def plotitinerary(cities,itin,plottitle,thename):
  lc = mc.LineCollection(genlines(cities,itin), linewidths=2)
  fig, ax = pl.subplots()
  ax.add_collection(lc)
  ax.autoscale()
  ax.margins(0.1)
  pl.scatter(x, y)
  pl.title(plottitle)
  pl.xlabel('X Coordinate')
  pl.ylabel('Y Coordinate')

plotitinerary(cities,itinerary,'TSP - Random Itinerary','figure2')
# По графику нетрудно догадаться, что мы еще не нашли лучшего решения задачи
# коммивояжера. Бедному коммивояжеру приходится несколько раз метаться по
# всей стране в отдаленные города; совершенно очевидно, что он мог бы действовать
# намного эффективнее
# Чтобы найти оптимальный маршрут можно использовать разные методы.
# Например метод грубой силы, который заключается в том, что сначала питон
# просчитывает все возможные маршруты между городами, после чего выбирает
# минимальные связки по расстоянию. 
# Для N городов общее число возможных маршрутов составит N! (N факториал)
# Однако значения более 10! - 15! уже запредельны для обычных компьютеров.
# Поэтому решать эту задачу нужно будет с помощью алгоритмов.